<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>API reference - damage</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../assets/_mkdocstrings.css" rel="stylesheet" />
        <link href="../css/extra.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "API reference";
        var mkdocs_page_input_path = "api_reference.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> damage
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Damage: file manifest tools</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../how_to_use_gui_damage/">How to use the Damage application</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../how_to_use_damage/">How to use the Damage console utility</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="#">API reference</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#damage">damage</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#damage.Checker">Checker</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#damage.Checker.hidden">hidden</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#damage.Checker.__del__">__del__</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#damage.Checker.__encoding">__encoding</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#damage.Checker.__init__">__init__</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#damage.Checker.__istextfile">__istextfile</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#damage.Checker.dos">dos</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#damage.Checker.flat_tester">flat_tester</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#damage.Checker.manifest">manifest</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#damage.Checker.non_ascii_tester">non_ascii_tester</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#damage.Checker.null_count">null_count</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#damage.Checker.produce_digest">produce_digest</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../faq/">Frequently asked questions</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../credits/">Credits</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">damage</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">API reference</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="api-reference">API Reference<a class="headerlink" href="#api-reference" title="Permanent link">&para;</a></h1>


<div class="doc doc-object doc-module">



<h2 id="damage" class="doc doc-heading">
            <code>damage</code>


<a href="#damage" class="headerlink" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents first">

        <p>Manifest generator for data files.</p>
<p>Produces a text file with user specificied checksums for all files
from the top of a specified tree and checks line length
and ASCII character status for text files.</p>
<p>For statistics program files:
  SAS .sas7bdat
  SPSS .sav
  Stata .dta</p>
<p>Checker() will report number of cases and variables as
rows and columns respectively.</p>










  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h3 id="damage.Checker" class="doc doc-heading">
            <code>Checker</code>


<a href="#damage.Checker" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">


        <p>A collection of various tools attached to a file</p>








              <details class="quote">
                <summary>Source code in <code>src/damage/__init__.py</code></summary>
                <pre class="codehilite"><code class="language-python">class Checker():
    '''
    A collection of various tools attached to a file
    '''

    def __init__(self, fname: str, **kwargs) -&gt; None: #DONE,
        '''
        Initializes Checker instance

        Parameters
        ----------
        fname : str
            Path to file
        **kwargs : dict
            Additional keyword parameters

        Other parameters
        ----------------
        weight : bool
            Weight towards a specific encoding
        target_encoding : str
            Specific target encoding, like 'cp1252'

        '''
        #Commercial stats files extensions
        #I am aware that extension checking is not perfect
        self.statfiles = ['.dta', '.sav', '.sas7bdat']
        #brute force is best force
        self.textfiles= ['.dat', '.txt', '.md', '.csv',
                        '.tsv', '.asc', '.html', '.xml',
                        '.xsd', '.htm', '.log', '.nfo',
                        '.text', '.xsl', '.py', '.r',
                         '.toml', '.yaml', '.yml', '.prn',
                         '.data']
        self.fname = pathlib.Path(fname)
        #self._ext = fname.suffix
        self.__istext = self.__istextfile()
        self.__text_obj = None

        with tqdm.tqdm(total=self.fname.stat().st_size,
                       desc=f'Loading {self.fname.name}') as pbar:
            self.__fobj_bin = io.BytesIO()
            with open(self.fname, 'rb') as f:
                bsize=2**16
                fblock  = f.read(bsize)
                pbar.update(bsize)
                while fblock:
                    self.__fobj_bin.write(fblock)
                    pbar.update(bsize)
                    fblock = f.read(bsize)


        self.encoding = self.__encoding(**kwargs)
        #Using RAM speeds it up by several orders of magnitude
        if self.__istext:
            self.__text_obj = io.StringIO(self.__fobj_bin.getvalue().decode(
                self.encoding.get('encoding', 'utf-8')))
            self.__fobj_bin.seek(0)

    @property
    def hidden(self)-&gt;bool:
        '''
        Returns True if file is hidden (ie, startswith '.')
        or is in in a hidden directory (ie, any directory on the path
        starts with '.')
        '''
        if any(x.startswith('.') for x in self.fname.parts):
            return True
        return False

    def __istextfile(self):
        '''
        Check to see if file is a text file based on mimetype.
        It's not perfect but at least it's something.
        '''
        try:
            if ('text' in mimetypes.guess_file_type(self.fname)
                or self.fname.suffix.lower() in self.textfiles):
                return True
        except AttributeError: #soft deprecation fix
            if ('text' in mimetypes.guess_type(self.fname)
                or self.fname.suffix.lower() in self.textfiles):
                return True

        return False

    def __encoding(self, weight:bool=True,#pylint: disable=unused-argument
                     target:str='cp1252',
                     **kwargs:dict)-&gt; dict:
        '''
        Returns most likely encoding of self.fname, dict with keys
        encoding, confidence, language
        and sets Checker.__is_text. It will make the assumption
        that if cp1252 (Windows-1252) is in the top 3, it *is*
        Windows-1252. Turn off this behaviour with 'weight'

        Parameters
        ----------
        weight : bool, default=True

        target : str, default='cp1252'
            If weight is True, if target appears in the top three encodings then the
            encoding will be assigned as target.
        **kwargs : dict
            Other miscellaneous things that may have been passed. They will be ignored.

        Notes
        -----
        Defaults to cp1252 because this was written to deal largely with
        Statistics Canada material, and that's in English or French. And apparently
        UTF-8 is too modern for them.
        '''
        encoding = {}
        read_position = 0
        enc_raw = charset_normalizer.from_bytes(self.__fobj_bin.getvalue())
        encoding['encoding'] = enc_raw.best().encoding
        if weight:
            if target in [x.encoding for x in enc_raw][:3]:
                read_position = [x.encoding for x in enc_raw][:3].index(target)
                print(f'read position:{read_position}')
        encoding['encoding'] = enc_raw[read_position].encoding
        encoding['language'] = enc_raw[read_position].language
        #Ripped straight from charset_normalizer source
        #confidence = 1.0 - r.chaos if r is not None else None
        encoding['confidence'] = 1.0 - enc_raw[read_position].chaos

        if self.__istext:
            return encoding

        return {'encoding': None,
                    'confidence': 0.0,
                    'language' : ''}

    def __del__(self) -&gt; None:#DONE
        '''
        Destructor closes file
        '''
        self.__fobj_bin.close()

    def produce_digest(self, prot: str = 'md5', blocksize: int = 2**16) -&gt; str: #DONE
        '''
        Returns hex digest for object

        Parameters
        ----------
        prot : str, default='md5'
            Hash type. Supported hashes: 'sha1', 'sha224', 'sha256',
            'sha384', 'sha512', 'blake2b', 'blake2s', 'md5'.
        blocksize : int
            Read block size in bytes
        '''
        ok_hash = {'sha1' : hashlib.sha1(),
                   'sha224' : hashlib.sha224(),
                   'sha256' : hashlib.sha256(),
                   'sha384' : hashlib.sha384(),
                   'sha512' : hashlib.sha512(),
                   'blake2b' : hashlib.blake2b(),
                   'blake2s' : hashlib.blake2s(),
                   'md5': hashlib.md5()}

        self.__fobj_bin.seek(0)
        try:
            _hash = ok_hash[prot]
        except (UnboundLocalError, KeyError):
            message = ('Unsupported hash type. Valid values are '
                       f'{list(ok_hash)}.')
            LOGGER.exception('Unsupported hash type. Valid values are %s', message)
            raise

        fblock = self.__fobj_bin.read(blocksize)
        while fblock:
            _hash.update(fblock)
            fblock = self.__fobj_bin.read(blocksize)
        return _hash.hexdigest()

    def flat_tester(self, **kwargs) -&gt; dict: #DONE
        '''
        Checks file for line length and number of records.

        Returns a dictionary:

        `{'min_cols': int, 'max_cols' : int, 'numrec':int, 'constant' : bool}`
        '''
        if not kwargs.get('flatfile'):
            return {'min_cols': 'N/A', 'max_cols': 'N/A', 'numrec' : 'N/A',
                    'constant': 'N/A', 'encoding' : 'N/A'}

        if self.fname.suffix.lower() in self.statfiles:
            return self._flat_tester_commercial(**kwargs)

        if self.__istext:
            return self._flat_tester_txt()
        #this should not happen but you never know
        return {'min_cols': 'N/A', 'max_cols': 'N/A', 'numrec' : 'N/A',
                'constant': 'N/A', 'encoding' : 'N/A'}

    def _flat_tester_commercial(self, **kwargs) -&gt; dict: #DONE
        '''
        Checks SPSS sav, SAS sas7bdat and Stata .dta files for rectangularity

        Returns a dictionary:

        `{'min_cols': int, 'max_cols': int, 'numrec' : int,
                    'constant': True, 'encoding': str}`

        These files are by definition rectanglar, at least as checked here
        by pyreadstat/pandas, so constant will always == True.

        Parameters
        ----------
        **kwargs : dict

        flatfile : bool
            If not flatfile check will be ignored
        '''
        if not kwargs.get('flatfile'):
            return {'min_cols': 'N/A', 'max_cols': 'N/A', 'numrec' : 'N/A',
                    'constant': 'N/A', 'encoding': 'N/A'}

        options = {'.sav' : pyreadstat.read_sav,
                   '.dta' : pyreadstat.read_dta,
                   '.sas7bdat' : pyreadstat.read_sas7bdat}

        #Note: Pyreadstat is written in C, and the C library
        #asks for file paths, so good luck getting it to read a BytesIO object
        start = time.perf_counter()
        #There is no obvious way to get a tqdm progress bar for this operation
        #short of reprogramming the C code, and that's not going to happen.
        #So you get this.
        print(f'Analyzing statistical package file {self.fname}.',
              file=sys.stderr, end=' ')
        #--------
        #Use multiprocessing, because no one can wait two hours to process
        #a single large file
        _, meta = pyreadstat.read_file_multiprocessing(
                                read_function=options[self.fname.suffix.lower()],
                                file_path=self.fname,
                                num_processes=multiprocessing.cpu_count())
        #-----------
        finish = time.perf_counter()
        print(f'Elapsed time: {round(finish - start, 2)} seconds.',
              file=sys.stderr)
        self.encoding['encoding'] = meta.file_encoding
        return {'min_cols':meta.number_columns,
                'max_cols':meta.number_columns,
                #'numrec': len(content),
                'numrec': meta.number_rows,
                'constant':True,
                'encoding': self.encoding['encoding']}

    def _flat_tester_txt(self) -&gt; dict: #DONE
        '''
        Checks file for line length and number of records.

        Returns a dictionary:

        `{'min_cols': int, 'max_cols' : int, 'numrec':int, 'constant' : bool}`
        '''
        linecount = 0
        self.__text_obj.seek(0)
        if not self.__istext:
            raise TypeError('Not a text file')
        maxline = len(self.__text_obj.readline())
        minline = maxline
        orig = maxline   # baseline to which new values are compared
        for row in self.__text_obj.readlines():
            linecount += 1
            maxline = max(maxline, len(row))
            minline = min(minline, len(row))
        constant = bool(maxline == orig == minline)
        self.__text_obj.seek(0)
        return {'min_cols': minline, 'max_cols': maxline, 'numrec' : linecount,
                'constant': constant, 'encoding': self.encoding['encoding']}

    def non_ascii_tester(self, **kwargs) -&gt; list: #DONE
        '''
        Returns a list of dicts of positions of non-ASCII characters in a text file.

        Parameters
        ----------
        **kwargs: dict

        Other parameters
        ----------------
        fname : str
            Path/filename
        flatfile : bool
            Boolean representing a flat ascii file
        asctest : bool
            Perform character check, if the file is a text file

        Returns
        -------
        `[{'row': int, 'col':int, 'char':str}...]`

        Notes
        -----
        returns [] if not self.__istext
        '''
        if (not kwargs.get('asctest', False)#AAAGH
            or not self.__istext
            or not kwargs.get('flatfile')):
            return []
        outlist = []
        total = self.__text_obj.getvalue().count('\n')+1
        self.__text_obj.seek(0)
        for rown, row in tqdm.tqdm(enumerate(self.__text_obj),
                                   total=total,
                                   desc=f'Non-ASCII character check for {self.fname.name}'):
            for coln, char in enumerate(row):
                if char not in string.printable and char != '\x00':
                    non_asc = {'row':rown+1, 'col': coln+1, 'char':char}
                    outlist.append(non_asc)
        self.__text_obj.seek(0)
        return outlist

    def null_count(self, **kwargs) -&gt; dict: #DONE
        '''
        Returns an integer count of null characters in the file
        ('\x00') or None if skipped

        Parameters
        ----------
        **kwargs : dict

        Other parameters
        ----------------
        flatfile : bool
            Test is useless if not a text file. If False, returns 'N/A'
        '''
        if (not kwargs.get('flatfile')
                or not self.__istext
                or not kwargs.get('null_chars')):
            return None
        if '\x00' in self.__text_obj.getvalue():
            return self.__text_obj.getvalue().count('\x00')
        return None

    def dos(self, **kwargs) -&gt; bool: #DONE
        '''
        Checks for presence of carriage returns in file

        Returns True if a carriage return ie, ord(13) is present

        Parameters
        ----------
        **kwargs : dict

        Other parameters
        ----------------
        flatfile : bool
            Perform rectangularity check. If False, returns dictionary
            with all values as 'N/A'
        '''
        if not kwargs.get('flatfile') or not self.__istext:
            return None
        return b'\r\n' in self.__fobj_bin.getvalue()

    def _mime_type(self, fname:pathlib.Path)-&gt;tuple:
        '''
        Returns mimetype or 'application/octet-stream'

        Parameters
        ---------
        fname : pathlib.Path
            pathlib.Path to file
        '''
        try:
            out = mimetypes.guess_file_type(fname, strict=False)[0]
        except AttributeError:
            #soft deprecation
            out = mimetypes.guess_type(fname)[0]
        if not out:
            out = 'application/octet-stream'
        return out

    def _report(self, **kwargs) -&gt; dict: #DONE
        '''
        Returns a dictionary of outputs based on keywords below.
        Performs each test and returns the appropriate values. A convenience
        function so that you don't have to run the tests individually.

        Parameters
        ----------
        **kwargs : dict
        digest : str
            Hash algorithm. Default 'md5'
        flat : bool
            Flat file checking.
        nonascii : bool
            Check for non-ASCII characters.
        flatfile : bool
            Perform rectangularity check. If False, returns dictionary
            with all values as 'N/A'
        null_chars : bool
            Check for null characters

        Notes
        -----
        Sample output:
        ```
        {'filename':'/tmp/test.csv',
        'flat': True,
        'min_cols': 100, 'max_cols': 100, 'numrec' : 101, 'constant': True,
        'nonascii':False,
        'dos':False}
        ```
        '''
        out = {'filename': self.fname}
        digest = kwargs.get('digest', 'md5')
        #dos = kwargs.get('dos')
        update_these = [
        {'digestType' : digest},
        {'digest' : self.produce_digest(digest)}, #OK
        self.flat_tester(**kwargs), #OK
        {'nonascii': self.non_ascii_tester(**kwargs)}, # Slow but acceptable
        {'encoding': self.encoding['encoding']}, #OK
        {'null_chars': self.null_count(**kwargs)}, #Not great, but better
        {'mimetype': self._mime_type(self.fname)}, #OK
        {'dos': self.dos(**kwargs)}]

        #for upd in tqdm.tqdm(update_these, desc='Processing'):
        for upd in update_these:
            out.update(upd)

        return out

    def _manifest_txt(self, **kwargs)-&gt;str:
        '''
        Returns manifest as plain text

        Parameters
        ----------
        **kwargs : dict
        '''
        return '\n'.join([f'{k}: {v}' for k,v in kwargs['report'].items()
                          if v not in ['', None]])

    def _manifest_json(self, **kwargs)-&gt;str:
        '''
        Returns manifest as JSON

        Parameters
        ----------
        **kwargs : dict
        '''
        out = kwargs['report'].copy()
        out['filename'] = str(kwargs['report']['filename'])
        return json.dumps(out)

    def _manifest_csv(self, **kwargs)-&gt;str:
        '''
        Returns manifest as [whatever]-separated value

        Parameters
        ----------
        **kwargs : dict
        '''
        outstr = io.StringIO(newline='')
        writer = csv.DictWriter(outstr, fieldnames=kwargs['report'].keys(),
                                delimiter=kwargs.get('sep', ','),
                                quoting=csv.QUOTE_MINIMAL)
        if kwargs.get('headers'):
            writer.writeheader()
        writer.writerow(kwargs['report'])
        outstr.seek(0)
        return outstr.read()

    def manifest(self, **kwargs) -&gt; str: #really as str #DONE
        '''
        Returns desired output type as string

        Parameters
        ----------
        **kwargs : dict

        Other parameters
        ----------------
        out : str
            Acceptable values are 'txt', 'json', 'csv'
            'txt' Plain text
            'json' JSON
            'csv' Comma-separated value
        digest : str
            Hash algorithm. Default 'md5'
        flat : bool
            Flat file checking. Default True
        nonascii : bool
            Check for non-ASCII characters. Default True
        dos : bool
            check for Windows CR/LF combo. Default True
        flatfile : bool
            Perform rectangularity check. If False, returns dictionary
            with all values as 'N/A'
        headers : bool, default=False
            Include csv header (only has any effect with out='csv')
        sep : str
            Separator if you want a different plain text separator like a
            tab (\t) or pipe (|). Only functional with csv output, obviously.
        '''
        report = self._report(**kwargs)
        report_type={'txt': self._manifest_txt,
                    'json': self._manifest_json,
                    'csv': self._manifest_csv,
                    'tsv': self._manifest_csv,
                    'psv': self._manifest_csv}

        try:
            return report_type[kwargs['out']](report=report, **kwargs)
        except KeyError:
            LOGGER.error('Unsupported manifest type %s; defaulting to text', kwargs['out'])
            return report_type[kwargs['out']](report=report, out='txt', **kwargs)</code></pre>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h4 id="damage.Checker.hidden" class="doc doc-heading">
            <code class=" language-python">hidden</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#damage.Checker.hidden" class="headerlink" title="Permanent link">&para;</a></h4>


    <div class="doc doc-contents ">

        <p>Returns True if file is hidden (ie, startswith &lsquo;.&rsquo;)
or is in in a hidden directory (ie, any directory on the path
starts with &lsquo;.&rsquo;)</p>

    </div>

</div>




<div class="doc doc-object doc-function">


<h4 id="damage.Checker.__del__" class="doc doc-heading">
            <code class=" language-python">__del__()</code>

<a href="#damage.Checker.__del__" class="headerlink" title="Permanent link">&para;</a></h4>


    <div class="doc doc-contents ">

        <p>Destructor closes file</p>


            <details class="quote">
              <summary>Source code in <code>src/damage/__init__.py</code></summary>
              <pre class="codehilite"><code class="language-python">def __del__(self) -&gt; None:#DONE
    '''
    Destructor closes file
    '''
    self.__fobj_bin.close()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="damage.Checker.__encoding" class="doc doc-heading">
            <code class=" language-python">__encoding(weight=True, target='cp1252', **kwargs)</code>

<a href="#damage.Checker.__encoding" class="headerlink" title="Permanent link">&para;</a></h4>


    <div class="doc doc-contents ">

        <p>Returns most likely encoding of self.fname, dict with keys
encoding, confidence, language
and sets Checker.__is_text. It will make the assumption
that if cp1252 (Windows-1252) is in the top 3, it <em>is</em>
Windows-1252. Turn off this behaviour with &lsquo;weight&rsquo;</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>weight</code></b>
                  (<code><span title="bool">bool</span></code>, default:
                      <code>True</code>
)
              –
              <div class="doc-md-description">
                
              </div>
            </li>
            <li>
              <b><code>target</code></b>
                  (<code><span title="str">str</span></code>, default:
                      <code>&#39;cp1252&#39;</code>
)
              –
              <div class="doc-md-description">
                <p>If weight is True, if target appears in the top three encodings then the
encoding will be assigned as target.</p>
              </div>
            </li>
            <li>
              <b><code>**kwargs</code></b>
                  (<code><span title="dict">dict</span></code>, default:
                      <code>{}</code>
)
              –
              <div class="doc-md-description">
                <p>Other miscellaneous things that may have been passed. They will be ignored.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<details class="note" open>
  <summary>Notes</summary>
  <p>Defaults to cp1252 because this was written to deal largely with
Statistics Canada material, and that&rsquo;s in English or French. And apparently
UTF-8 is too modern for them.</p>
</details>

            <details class="quote">
              <summary>Source code in <code>src/damage/__init__.py</code></summary>
              <pre class="codehilite"><code class="language-python">def __encoding(self, weight:bool=True,#pylint: disable=unused-argument
                 target:str='cp1252',
                 **kwargs:dict)-&gt; dict:
    '''
    Returns most likely encoding of self.fname, dict with keys
    encoding, confidence, language
    and sets Checker.__is_text. It will make the assumption
    that if cp1252 (Windows-1252) is in the top 3, it *is*
    Windows-1252. Turn off this behaviour with 'weight'

    Parameters
    ----------
    weight : bool, default=True

    target : str, default='cp1252'
        If weight is True, if target appears in the top three encodings then the
        encoding will be assigned as target.
    **kwargs : dict
        Other miscellaneous things that may have been passed. They will be ignored.

    Notes
    -----
    Defaults to cp1252 because this was written to deal largely with
    Statistics Canada material, and that's in English or French. And apparently
    UTF-8 is too modern for them.
    '''
    encoding = {}
    read_position = 0
    enc_raw = charset_normalizer.from_bytes(self.__fobj_bin.getvalue())
    encoding['encoding'] = enc_raw.best().encoding
    if weight:
        if target in [x.encoding for x in enc_raw][:3]:
            read_position = [x.encoding for x in enc_raw][:3].index(target)
            print(f'read position:{read_position}')
    encoding['encoding'] = enc_raw[read_position].encoding
    encoding['language'] = enc_raw[read_position].language
    #Ripped straight from charset_normalizer source
    #confidence = 1.0 - r.chaos if r is not None else None
    encoding['confidence'] = 1.0 - enc_raw[read_position].chaos

    if self.__istext:
        return encoding

    return {'encoding': None,
                'confidence': 0.0,
                'language' : ''}</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="damage.Checker.__init__" class="doc doc-heading">
            <code class=" language-python">__init__(fname, **kwargs)</code>

<a href="#damage.Checker.__init__" class="headerlink" title="Permanent link">&para;</a></h4>


    <div class="doc doc-contents ">

        <p>Initializes Checker instance</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>fname</code></b>
                  (<code><span title="str">str</span></code>)
              –
              <div class="doc-md-description">
                <p>Path to file</p>
              </div>
            </li>
            <li>
              <b><code>**kwargs</code></b>
                  (<code><span title="dict">dict</span></code>, default:
                      <code>{}</code>
)
              –
              <div class="doc-md-description">
                <p>Additional keyword parameters</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name"></th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>weight</code></b>
                  (<code><span title="bool">bool</span></code>)
              –
              <div class="doc-md-description">
                <p>Weight towards a specific encoding</p>
              </div>
            </li>
            <li>
              <b><code>target_encoding</code></b>
                  (<code><span title="str">str</span></code>)
              –
              <div class="doc-md-description">
                <p>Specific target encoding, like &lsquo;cp1252&rsquo;</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>src/damage/__init__.py</code></summary>
              <pre class="codehilite"><code class="language-python">def __init__(self, fname: str, **kwargs) -&gt; None: #DONE,
    '''
    Initializes Checker instance

    Parameters
    ----------
    fname : str
        Path to file
    **kwargs : dict
        Additional keyword parameters

    Other parameters
    ----------------
    weight : bool
        Weight towards a specific encoding
    target_encoding : str
        Specific target encoding, like 'cp1252'

    '''
    #Commercial stats files extensions
    #I am aware that extension checking is not perfect
    self.statfiles = ['.dta', '.sav', '.sas7bdat']
    #brute force is best force
    self.textfiles= ['.dat', '.txt', '.md', '.csv',
                    '.tsv', '.asc', '.html', '.xml',
                    '.xsd', '.htm', '.log', '.nfo',
                    '.text', '.xsl', '.py', '.r',
                     '.toml', '.yaml', '.yml', '.prn',
                     '.data']
    self.fname = pathlib.Path(fname)
    #self._ext = fname.suffix
    self.__istext = self.__istextfile()
    self.__text_obj = None

    with tqdm.tqdm(total=self.fname.stat().st_size,
                   desc=f'Loading {self.fname.name}') as pbar:
        self.__fobj_bin = io.BytesIO()
        with open(self.fname, 'rb') as f:
            bsize=2**16
            fblock  = f.read(bsize)
            pbar.update(bsize)
            while fblock:
                self.__fobj_bin.write(fblock)
                pbar.update(bsize)
                fblock = f.read(bsize)


    self.encoding = self.__encoding(**kwargs)
    #Using RAM speeds it up by several orders of magnitude
    if self.__istext:
        self.__text_obj = io.StringIO(self.__fobj_bin.getvalue().decode(
            self.encoding.get('encoding', 'utf-8')))
        self.__fobj_bin.seek(0)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="damage.Checker.__istextfile" class="doc doc-heading">
            <code class=" language-python">__istextfile()</code>

<a href="#damage.Checker.__istextfile" class="headerlink" title="Permanent link">&para;</a></h4>


    <div class="doc doc-contents ">

        <p>Check to see if file is a text file based on mimetype.
It&rsquo;s not perfect but at least it&rsquo;s something.</p>


            <details class="quote">
              <summary>Source code in <code>src/damage/__init__.py</code></summary>
              <pre class="codehilite"><code class="language-python">def __istextfile(self):
    '''
    Check to see if file is a text file based on mimetype.
    It's not perfect but at least it's something.
    '''
    try:
        if ('text' in mimetypes.guess_file_type(self.fname)
            or self.fname.suffix.lower() in self.textfiles):
            return True
    except AttributeError: #soft deprecation fix
        if ('text' in mimetypes.guess_type(self.fname)
            or self.fname.suffix.lower() in self.textfiles):
            return True

    return False</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="damage.Checker.dos" class="doc doc-heading">
            <code class=" language-python">dos(**kwargs)</code>

<a href="#damage.Checker.dos" class="headerlink" title="Permanent link">&para;</a></h4>


    <div class="doc doc-contents ">

        <p>Checks for presence of carriage returns in file</p>
<p>Returns True if a carriage return ie, ord(13) is present</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>**kwargs</code></b>
                  (<code><span title="dict">dict</span></code>, default:
                      <code>{}</code>
)
              –
              <div class="doc-md-description">
                
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name"></th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>flatfile</code></b>
                  (<code><span title="bool">bool</span></code>)
              –
              <div class="doc-md-description">
                <p>Perform rectangularity check. If False, returns dictionary
with all values as &lsquo;N/A&rsquo;</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>src/damage/__init__.py</code></summary>
              <pre class="codehilite"><code class="language-python">def dos(self, **kwargs) -&gt; bool: #DONE
    '''
    Checks for presence of carriage returns in file

    Returns True if a carriage return ie, ord(13) is present

    Parameters
    ----------
    **kwargs : dict

    Other parameters
    ----------------
    flatfile : bool
        Perform rectangularity check. If False, returns dictionary
        with all values as 'N/A'
    '''
    if not kwargs.get('flatfile') or not self.__istext:
        return None
    return b'\r\n' in self.__fobj_bin.getvalue()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="damage.Checker.flat_tester" class="doc doc-heading">
            <code class=" language-python">flat_tester(**kwargs)</code>

<a href="#damage.Checker.flat_tester" class="headerlink" title="Permanent link">&para;</a></h4>


    <div class="doc doc-contents ">

        <p>Checks file for line length and number of records.</p>
<p>Returns a dictionary:</p>
<p><code>{'min_cols': int, 'max_cols' : int, 'numrec':int, 'constant' : bool}</code></p>


            <details class="quote">
              <summary>Source code in <code>src/damage/__init__.py</code></summary>
              <pre class="codehilite"><code class="language-python">def flat_tester(self, **kwargs) -&gt; dict: #DONE
    '''
    Checks file for line length and number of records.

    Returns a dictionary:

    `{'min_cols': int, 'max_cols' : int, 'numrec':int, 'constant' : bool}`
    '''
    if not kwargs.get('flatfile'):
        return {'min_cols': 'N/A', 'max_cols': 'N/A', 'numrec' : 'N/A',
                'constant': 'N/A', 'encoding' : 'N/A'}

    if self.fname.suffix.lower() in self.statfiles:
        return self._flat_tester_commercial(**kwargs)

    if self.__istext:
        return self._flat_tester_txt()
    #this should not happen but you never know
    return {'min_cols': 'N/A', 'max_cols': 'N/A', 'numrec' : 'N/A',
            'constant': 'N/A', 'encoding' : 'N/A'}</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="damage.Checker.manifest" class="doc doc-heading">
            <code class=" language-python">manifest(**kwargs)</code>

<a href="#damage.Checker.manifest" class="headerlink" title="Permanent link">&para;</a></h4>


    <div class="doc doc-contents ">

        <p>Returns desired output type as string</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>**kwargs</code></b>
                  (<code><span title="dict">dict</span></code>, default:
                      <code>{}</code>
)
              –
              <div class="doc-md-description">
                
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name"></th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>out</code></b>
                  (<code><span title="str">str</span></code>)
              –
              <div class="doc-md-description">
                <p>Acceptable values are &lsquo;txt&rsquo;, &lsquo;json&rsquo;, &lsquo;csv&rsquo;
&lsquo;txt&rsquo; Plain text
&lsquo;json&rsquo; JSON
&lsquo;csv&rsquo; Comma-separated value</p>
              </div>
            </li>
            <li>
              <b><code>digest</code></b>
                  (<code><span title="str">str</span></code>)
              –
              <div class="doc-md-description">
                <p>Hash algorithm. Default &lsquo;md5&rsquo;</p>
              </div>
            </li>
            <li>
              <b><code>flat</code></b>
                  (<code><span title="bool">bool</span></code>)
              –
              <div class="doc-md-description">
                <p>Flat file checking. Default True</p>
              </div>
            </li>
            <li>
              <b><code>nonascii</code></b>
                  (<code><span title="bool">bool</span></code>)
              –
              <div class="doc-md-description">
                <p>Check for non-ASCII characters. Default True</p>
              </div>
            </li>
            <li>
              <b><code>dos</code></b>
                  (<code><span title="bool">bool</span></code>)
              –
              <div class="doc-md-description">
                <p>check for Windows CR/LF combo. Default True</p>
              </div>
            </li>
            <li>
              <b><code>flatfile</code></b>
                  (<code><span title="bool">bool</span></code>)
              –
              <div class="doc-md-description">
                <p>Perform rectangularity check. If False, returns dictionary
with all values as &lsquo;N/A&rsquo;</p>
              </div>
            </li>
            <li>
              <b><code>headers</code></b>
                  (<code><span title="bool">bool</span></code>)
              –
              <div class="doc-md-description">
                <p>Include csv header (only has any effect with out=&rsquo;csv&rsquo;)</p>
              </div>
            </li>
            <li>
              <b><code>sep</code></b>
                  (<code><span title="str">str</span></code>)
              –
              <div class="doc-md-description">
                <p>Separator if you want a different plain text separator like a
tab (       ) or pipe (|). Only functional with csv output, obviously.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>src/damage/__init__.py</code></summary>
              <pre class="codehilite"><code class="language-python">def manifest(self, **kwargs) -&gt; str: #really as str #DONE
    '''
    Returns desired output type as string

    Parameters
    ----------
    **kwargs : dict

    Other parameters
    ----------------
    out : str
        Acceptable values are 'txt', 'json', 'csv'
        'txt' Plain text
        'json' JSON
        'csv' Comma-separated value
    digest : str
        Hash algorithm. Default 'md5'
    flat : bool
        Flat file checking. Default True
    nonascii : bool
        Check for non-ASCII characters. Default True
    dos : bool
        check for Windows CR/LF combo. Default True
    flatfile : bool
        Perform rectangularity check. If False, returns dictionary
        with all values as 'N/A'
    headers : bool, default=False
        Include csv header (only has any effect with out='csv')
    sep : str
        Separator if you want a different plain text separator like a
        tab (\t) or pipe (|). Only functional with csv output, obviously.
    '''
    report = self._report(**kwargs)
    report_type={'txt': self._manifest_txt,
                'json': self._manifest_json,
                'csv': self._manifest_csv,
                'tsv': self._manifest_csv,
                'psv': self._manifest_csv}

    try:
        return report_type[kwargs['out']](report=report, **kwargs)
    except KeyError:
        LOGGER.error('Unsupported manifest type %s; defaulting to text', kwargs['out'])
        return report_type[kwargs['out']](report=report, out='txt', **kwargs)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="damage.Checker.non_ascii_tester" class="doc doc-heading">
            <code class=" language-python">non_ascii_tester(**kwargs)</code>

<a href="#damage.Checker.non_ascii_tester" class="headerlink" title="Permanent link">&para;</a></h4>


    <div class="doc doc-contents ">

        <p>Returns a list of dicts of positions of non-ASCII characters in a text file.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>**kwargs</code></b>
              –
              <div class="doc-md-description">
                
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name"></th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>fname</code></b>
                  (<code><span title="str">str</span></code>)
              –
              <div class="doc-md-description">
                <p>Path/filename</p>
              </div>
            </li>
            <li>
              <b><code>flatfile</code></b>
                  (<code><span title="bool">bool</span></code>)
              –
              <div class="doc-md-description">
                <p>Boolean representing a flat ascii file</p>
              </div>
            </li>
            <li>
              <b><code>asctest</code></b>
                  (<code><span title="bool">bool</span></code>)
              –
              <div class="doc-md-description">
                <p>Perform character check, if the file is a text file</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code>`[{&#39;row&#39;: int, &#39;col&#39;:int, &#39;char&#39;:str}...]`</code>
              –
              <div class="doc-md-description">
                
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<details class="note" open>
  <summary>Notes</summary>
  <p>returns [] if not self.__istext</p>
</details>

            <details class="quote">
              <summary>Source code in <code>src/damage/__init__.py</code></summary>
              <pre class="codehilite"><code class="language-python">def non_ascii_tester(self, **kwargs) -&gt; list: #DONE
    '''
    Returns a list of dicts of positions of non-ASCII characters in a text file.

    Parameters
    ----------
    **kwargs: dict

    Other parameters
    ----------------
    fname : str
        Path/filename
    flatfile : bool
        Boolean representing a flat ascii file
    asctest : bool
        Perform character check, if the file is a text file

    Returns
    -------
    `[{'row': int, 'col':int, 'char':str}...]`

    Notes
    -----
    returns [] if not self.__istext
    '''
    if (not kwargs.get('asctest', False)#AAAGH
        or not self.__istext
        or not kwargs.get('flatfile')):
        return []
    outlist = []
    total = self.__text_obj.getvalue().count('\n')+1
    self.__text_obj.seek(0)
    for rown, row in tqdm.tqdm(enumerate(self.__text_obj),
                               total=total,
                               desc=f'Non-ASCII character check for {self.fname.name}'):
        for coln, char in enumerate(row):
            if char not in string.printable and char != '\x00':
                non_asc = {'row':rown+1, 'col': coln+1, 'char':char}
                outlist.append(non_asc)
    self.__text_obj.seek(0)
    return outlist</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="damage.Checker.null_count" class="doc doc-heading">
            <code class=" language-python">null_count(**kwargs)</code>

<a href="#damage.Checker.null_count" class="headerlink" title="Permanent link">&para;</a></h4>


    <div class="doc doc-contents ">

        <p>Returns an integer count of null characters in the file
(&lsquo; &rsquo;) or None if skipped</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>**kwargs</code></b>
                  (<code><span title="dict">dict</span></code>, default:
                      <code>{}</code>
)
              –
              <div class="doc-md-description">
                
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name"></th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>flatfile</code></b>
                  (<code><span title="bool">bool</span></code>)
              –
              <div class="doc-md-description">
                <p>Test is useless if not a text file. If False, returns &lsquo;N/A&rsquo;</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>src/damage/__init__.py</code></summary>
              <pre class="codehilite"><code class="language-python">def null_count(self, **kwargs) -&gt; dict: #DONE
    '''
    Returns an integer count of null characters in the file
    ('\x00') or None if skipped

    Parameters
    ----------
    **kwargs : dict

    Other parameters
    ----------------
    flatfile : bool
        Test is useless if not a text file. If False, returns 'N/A'
    '''
    if (not kwargs.get('flatfile')
            or not self.__istext
            or not kwargs.get('null_chars')):
        return None
    if '\x00' in self.__text_obj.getvalue():
        return self.__text_obj.getvalue().count('\x00')
    return None</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="damage.Checker.produce_digest" class="doc doc-heading">
            <code class=" language-python">produce_digest(prot='md5', blocksize=2 ** 16)</code>

<a href="#damage.Checker.produce_digest" class="headerlink" title="Permanent link">&para;</a></h4>


    <div class="doc doc-contents ">

        <p>Returns hex digest for object</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>prot</code></b>
                  (<code><span title="str">str</span></code>, default:
                      <code>&#39;md5&#39;</code>
)
              –
              <div class="doc-md-description">
                <p>Hash type. Supported hashes: &lsquo;sha1&rsquo;, &lsquo;sha224&rsquo;, &lsquo;sha256&rsquo;,
&lsquo;sha384&rsquo;, &lsquo;sha512&rsquo;, &lsquo;blake2b&rsquo;, &lsquo;blake2s&rsquo;, &lsquo;md5&rsquo;.</p>
              </div>
            </li>
            <li>
              <b><code>blocksize</code></b>
                  (<code><span title="int">int</span></code>, default:
                      <code>2 ** 16</code>
)
              –
              <div class="doc-md-description">
                <p>Read block size in bytes</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="quote">
              <summary>Source code in <code>src/damage/__init__.py</code></summary>
              <pre class="codehilite"><code class="language-python">def produce_digest(self, prot: str = 'md5', blocksize: int = 2**16) -&gt; str: #DONE
    '''
    Returns hex digest for object

    Parameters
    ----------
    prot : str, default='md5'
        Hash type. Supported hashes: 'sha1', 'sha224', 'sha256',
        'sha384', 'sha512', 'blake2b', 'blake2s', 'md5'.
    blocksize : int
        Read block size in bytes
    '''
    ok_hash = {'sha1' : hashlib.sha1(),
               'sha224' : hashlib.sha224(),
               'sha256' : hashlib.sha256(),
               'sha384' : hashlib.sha384(),
               'sha512' : hashlib.sha512(),
               'blake2b' : hashlib.blake2b(),
               'blake2s' : hashlib.blake2s(),
               'md5': hashlib.md5()}

    self.__fobj_bin.seek(0)
    try:
        _hash = ok_hash[prot]
    except (UnboundLocalError, KeyError):
        message = ('Unsupported hash type. Valid values are '
                   f'{list(ok_hash)}.')
        LOGGER.exception('Unsupported hash type. Valid values are %s', message)
        raise

    fblock = self.__fobj_bin.read(blocksize)
    while fblock:
        _hash.update(fblock)
        fblock = self.__fobj_bin.read(blocksize)
    return _hash.hexdigest()</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../how_to_use_damage/" class="btn btn-neutral float-left" title="How to use the Damage console utility"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../faq/" class="btn btn-neutral float-right" title="Frequently asked questions">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../how_to_use_damage/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../faq/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
