{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"File manifest tools: Damage and FCheck \u00b6 Overview \u00b6 Damage (either DAtaMAnifestGEnerator or a wizard, your choice) is a simple multi-platform utility which creates file manifests in a variety of formats. It was created to deal primarily with statistical data, but it also functions as a generalized file manifest tool. Download the newest binary version of Damage here: Windows MacOS A created manifest includes, for all file types: The file name Checksum in your choice of hash for the file. Current flavours of hashes are: sha1, sha224, sha256, sha384, sha512, blake2b, blake2s, md5 Encoding, if available (ie, utf-8, windows-1252, etc.) For plain text files , often used for microdata, the utility also produces information on: Minimum line length Maximum line length Number of records Constant records flag (ie, all lines are of the same length) Row and column of non-ASCII characters A count of null characters Flag for DOS/Windows formatting (ie, carriage return + line feed as opposed to just a line feed). For files in SAS, SPSS and Stata formats (ie, .sas7bdat, .sav and .dta) the utility will provide information on: Number of cases (reported as rows) Number of variables (reported as columns) Note that statistical package files will always be reported as rectangular due to the limitations of parsing them. Output formats are: Plain text Comma Separated Value (ie, a spreadsheet) JSON. This JSON doesn\u2019t conform to any particular standard, but is valid JSON object \u2014 one object for all the files. The command line program will produce output in the format of: {\"files\":[{file1medata}, {file2metadata}, ...{fileNmetadata}]} But that\u2019s not all! \u00b6 The fcheck module \u00b6 While damage is the standalone piece of software that most people will use, the underlying checking mechanism is available as a Python module called fcheck which you can use in your own software. Why would I need this? \u00b6 More than ever, the world today revolves around data sharing. Knowing the data that you\u2019ve downloaded is correct is key. For data distributors damage output can be included as a text file with your data so that you and end users can verify and identify what they\u2019ve downloaded Create detailed version notes with one command Manage changes in file structure using digests which are unique to a particular version of a file, instead of relying on easily changeable file names Easily find duplicate files For researchers damage and fcheck can help with creating descriptive documentation which is required for your research data deposit damage output ensures the integrity of your data set when used by others Obtaining the software/installation \u00b6 Binary files \u00b6 Console binaries of the damage utility are available for Windows and Mac (Intel) at fcheck\u2019s release page https://github.com/ubc-library-rc/fcheck/releases . If you don\u2019t already have Python 3 installed (and potentially other python libraries) or you just don\u2019t want to use Python this is the easiest way to proceed. These files don\u2019t need installation and can be run directly from the command line. For ease of use, you might consider adding the files to your PATH. Windows users \u00b6 The download should be in a directory that is listed in the %PATH% environment variable. The easiest way to do this is to use the Start menu and type \u201cEnvironment\u201d, then select \u201cEdit Environment variables for your account\u201d. Either place the binary file into a directory listed in Path , or add a new directory to your path using the GUI. Mac users \u00b6 The easiest way to make this available system wide is simply to copy the Mac executable to the /usr/local/bin directory, which is normally found on the primary drive. In the finder, press CMD-SHIFT-G, then type /usr/local/bin in the box to easily find it. Installing with pip \u00b6 The software is written in Python (>= 3.6), and the source is available as a single file in fcheck.py . If you have Python 3 installed you can either just download that single file to a place of convenience, or you can install it as a Python library by running the following commands in a terminal: pip install git+https://github.com/ubc-library-rc/fcheck.git@master This second method installs the damage command line utility and will also allow you to use the fcheck.Checker class in your own projects, in the traditional import fcheck sort of way. If you don\u2019t care about that, just download a binary or use the Python file directly. It will also automatically install the dependencies for you. Documentation on the module is available via the API reference documentation . Updating with with pip \u00b6 pip install --upgrade git+https://github.com/ubc-library-rc/fcheck.git@master Because the software is not hosted at PyPi, there is a slightly longer update string. Source code \u00b6 As you may have surmised from the example above, source code is available at https://github.com/ubc-library-rc/fcheck , along with all of the documentation and binary files.","title":"File manifest tools damage and fcheck"},{"location":"#file-manifest-tools-damage-and-fcheck","text":"","title":"File manifest tools: Damage and FCheck"},{"location":"#overview","text":"Damage (either DAtaMAnifestGEnerator or a wizard, your choice) is a simple multi-platform utility which creates file manifests in a variety of formats. It was created to deal primarily with statistical data, but it also functions as a generalized file manifest tool. Download the newest binary version of Damage here: Windows MacOS A created manifest includes, for all file types: The file name Checksum in your choice of hash for the file. Current flavours of hashes are: sha1, sha224, sha256, sha384, sha512, blake2b, blake2s, md5 Encoding, if available (ie, utf-8, windows-1252, etc.) For plain text files , often used for microdata, the utility also produces information on: Minimum line length Maximum line length Number of records Constant records flag (ie, all lines are of the same length) Row and column of non-ASCII characters A count of null characters Flag for DOS/Windows formatting (ie, carriage return + line feed as opposed to just a line feed). For files in SAS, SPSS and Stata formats (ie, .sas7bdat, .sav and .dta) the utility will provide information on: Number of cases (reported as rows) Number of variables (reported as columns) Note that statistical package files will always be reported as rectangular due to the limitations of parsing them. Output formats are: Plain text Comma Separated Value (ie, a spreadsheet) JSON. This JSON doesn\u2019t conform to any particular standard, but is valid JSON object \u2014 one object for all the files. The command line program will produce output in the format of: {\"files\":[{file1medata}, {file2metadata}, ...{fileNmetadata}]}","title":"Overview"},{"location":"#but-thats-not-all","text":"","title":"But that's not all!"},{"location":"#the-fcheck-module","text":"While damage is the standalone piece of software that most people will use, the underlying checking mechanism is available as a Python module called fcheck which you can use in your own software.","title":"The fcheck module"},{"location":"#why-would-i-need-this","text":"More than ever, the world today revolves around data sharing. Knowing the data that you\u2019ve downloaded is correct is key. For data distributors damage output can be included as a text file with your data so that you and end users can verify and identify what they\u2019ve downloaded Create detailed version notes with one command Manage changes in file structure using digests which are unique to a particular version of a file, instead of relying on easily changeable file names Easily find duplicate files For researchers damage and fcheck can help with creating descriptive documentation which is required for your research data deposit damage output ensures the integrity of your data set when used by others","title":"Why would I need this?"},{"location":"#obtaining-the-softwareinstallation","text":"","title":"Obtaining the software/installation"},{"location":"#binary-files","text":"Console binaries of the damage utility are available for Windows and Mac (Intel) at fcheck\u2019s release page https://github.com/ubc-library-rc/fcheck/releases . If you don\u2019t already have Python 3 installed (and potentially other python libraries) or you just don\u2019t want to use Python this is the easiest way to proceed. These files don\u2019t need installation and can be run directly from the command line. For ease of use, you might consider adding the files to your PATH.","title":"Binary files"},{"location":"#windows-users","text":"The download should be in a directory that is listed in the %PATH% environment variable. The easiest way to do this is to use the Start menu and type \u201cEnvironment\u201d, then select \u201cEdit Environment variables for your account\u201d. Either place the binary file into a directory listed in Path , or add a new directory to your path using the GUI.","title":"Windows users"},{"location":"#mac-users","text":"The easiest way to make this available system wide is simply to copy the Mac executable to the /usr/local/bin directory, which is normally found on the primary drive. In the finder, press CMD-SHIFT-G, then type /usr/local/bin in the box to easily find it.","title":"Mac users"},{"location":"#installing-with-pip","text":"The software is written in Python (>= 3.6), and the source is available as a single file in fcheck.py . If you have Python 3 installed you can either just download that single file to a place of convenience, or you can install it as a Python library by running the following commands in a terminal: pip install git+https://github.com/ubc-library-rc/fcheck.git@master This second method installs the damage command line utility and will also allow you to use the fcheck.Checker class in your own projects, in the traditional import fcheck sort of way. If you don\u2019t care about that, just download a binary or use the Python file directly. It will also automatically install the dependencies for you. Documentation on the module is available via the API reference documentation .","title":"Installing with pip"},{"location":"#updating-with-with-pip","text":"pip install --upgrade git+https://github.com/ubc-library-rc/fcheck.git@master Because the software is not hosted at PyPi, there is a slightly longer update string.","title":"Updating with with pip"},{"location":"#source-code","text":"As you may have surmised from the example above, source code is available at https://github.com/ubc-library-rc/fcheck , along with all of the documentation and binary files.","title":"Source code"},{"location":"api_reference/","text":"API Reference \u00b6 fcheck \u00b6 Manifest generator for data files. Produces a text file with user specificied checksums for all files from the top of a specified tree and checks line length and ASCII character status for text files. For statistics program files: SAS .sas7bdat SPSS .sav Stata .dta Checker() will report number of cases and variables as rows and columns respectively. Checker Objects \u00b6 class Checker() A collection of various tools attached to a file __init__ \u00b6 | __init__(fname: str) Initializes Checker instance fname : str Path to file __del__ \u00b6 | __del__() Destructor closes file produce_digest \u00b6 | produce_digest(prot: str = 'md5', blocksize: int = 2*16) -> str Returns hex digest for object fname : str Path to a file object prot : str Hash type. Supported hashes: 'sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'blake2b', 'blake2s', 'md5'. Default: 'md5' blocksize : int Read block size in bytes flat_tester \u00b6 | flat_tester(**kwargs) -> dict Checks file for line length and number of records. Returns a dictionary: {'min_cols': int, 'max_cols' : int, 'numrec':int, 'constant' : bool} non_ascii_tester \u00b6 | non_ascii_tester(**kwargs) -> list Returns a list of dicts of positions of non-ASCII characters in a text file. [{'row': int, 'col':int, 'char':str}...] fname : str Path/filename Keyword arguments: flatfile : bool \u2014 Perform rectangularity check. If False, returns dictionary with all values as 'N/A' null_count \u00b6 | null_count(**kwargs) -> dict Returns an integer count of null characters in the file (\u2018\\x00\u2019) or None if skipped Keyword arguments: flatfile : bool \u2014 Test is useless if not a text file. If False, returns 'N/A' dos \u00b6 | dos(**kwargs) -> bool Checks for presence of carriage returns in file Returns True if a carriage return ie, ord(13) is present Keyword arguments: flatfile : bool \u2014 Perform rectangularity check. If False, returns dictionary with all values as 'N/A' manifest \u00b6 | manifest(out: str = 'txt', **kwargs) Returns your desired output type as string out : str \u2014 Acceptable values are \u2018txt\u2019, \u2018csv\u2019, \u2018json\u2019 Accepted keywords and defaults: digest : str \u2014 Hash algorithm. Default \u2018md5\u2019 flat : bool \u2014 Flat file checking. Default True nonascii : bool \u2014 Check for non-ASCII characters. Default True dos : bool \u2014 check for Windows CR/LF combo. Default True flatfile : bool \u2014 Perform rectangularity check. If False, returns dictionary with all values as 'N/A' headers : bool \u2014 Include csv header (only has any effect with out='csv') Default is False","title":"API reference for fcheck"},{"location":"api_reference/#api-reference","text":"","title":"API Reference"},{"location":"api_reference/#fcheck","text":"Manifest generator for data files. Produces a text file with user specificied checksums for all files from the top of a specified tree and checks line length and ASCII character status for text files. For statistics program files: SAS .sas7bdat SPSS .sav Stata .dta Checker() will report number of cases and variables as rows and columns respectively.","title":"fcheck"},{"location":"api_reference/#checker-objects","text":"class Checker() A collection of various tools attached to a file","title":"Checker Objects"},{"location":"api_reference/#__init__","text":"| __init__(fname: str) Initializes Checker instance fname : str Path to file","title":"__init__"},{"location":"api_reference/#__del__","text":"| __del__() Destructor closes file","title":"__del__"},{"location":"api_reference/#produce_digest","text":"| produce_digest(prot: str = 'md5', blocksize: int = 2*16) -> str Returns hex digest for object fname : str Path to a file object prot : str Hash type. Supported hashes: 'sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'blake2b', 'blake2s', 'md5'. Default: 'md5' blocksize : int Read block size in bytes","title":"produce_digest"},{"location":"api_reference/#flat_tester","text":"| flat_tester(**kwargs) -> dict Checks file for line length and number of records. Returns a dictionary: {'min_cols': int, 'max_cols' : int, 'numrec':int, 'constant' : bool}","title":"flat_tester"},{"location":"api_reference/#non_ascii_tester","text":"| non_ascii_tester(**kwargs) -> list Returns a list of dicts of positions of non-ASCII characters in a text file. [{'row': int, 'col':int, 'char':str}...] fname : str Path/filename Keyword arguments: flatfile : bool \u2014 Perform rectangularity check. If False, returns dictionary with all values as 'N/A'","title":"non_ascii_tester"},{"location":"api_reference/#null_count","text":"| null_count(**kwargs) -> dict Returns an integer count of null characters in the file (\u2018\\x00\u2019) or None if skipped Keyword arguments: flatfile : bool \u2014 Test is useless if not a text file. If False, returns 'N/A'","title":"null_count"},{"location":"api_reference/#dos","text":"| dos(**kwargs) -> bool Checks for presence of carriage returns in file Returns True if a carriage return ie, ord(13) is present Keyword arguments: flatfile : bool \u2014 Perform rectangularity check. If False, returns dictionary with all values as 'N/A'","title":"dos"},{"location":"api_reference/#manifest","text":"| manifest(out: str = 'txt', **kwargs) Returns your desired output type as string out : str \u2014 Acceptable values are \u2018txt\u2019, \u2018csv\u2019, \u2018json\u2019 Accepted keywords and defaults: digest : str \u2014 Hash algorithm. Default \u2018md5\u2019 flat : bool \u2014 Flat file checking. Default True nonascii : bool \u2014 Check for non-ASCII characters. Default True dos : bool \u2014 check for Windows CR/LF combo. Default True flatfile : bool \u2014 Perform rectangularity check. If False, returns dictionary with all values as 'N/A' headers : bool \u2014 Include csv header (only has any effect with out='csv') Default is False","title":"manifest"},{"location":"building_damage_binary/","text":"Creating a binary damage \u00b6 Not everyone has a python installation on their computer, and even if they do, they don\u2019t necessarily know how to use it. As damage is supposed to be simple to use, the easiest way to use it is as a traditional application. This means it needs to be compiled or packaged into, ideally, a single file. Note that you only need to this if there is not a binary version of damage available for your platform. Normally you would just download the software from the releases page. Users most likely to require a custom binary version of damage are: Linux users Mac users who are using machines with M1 processors Users with ARM chips or other uncommon system architecture To perform these steps, you will need [PyInstaller] along with an installed version of Python >= v3.6. Although these examples use absolute paths, that\u2019s not technically required. You can install PyInstaller the usual way with pip . ie. pip install PyInstaller Building with Pyinstaller \u00b6 Depending on your Python installation, you may need to build with a virtual environment (which you should probably do anyway). Damage doesn\u2019t have a lot of dependencies; you really only need pyreadstat, which installs pandas and numpy as dependencies. or, as the output of pip freeze : altgraph==0.17 importlib-metadata==4.0.1 macholib==1.14 numpy==1.20.2 pandas==1.2.4 pyinstaller==4.3 pyinstaller-hooks-contrib==2021.1 pyreadstat==1.1.0 python-dateutil==2.8.1 pytz==2021.1 six==1.15.0 typing-extensions==3.10.0.0 zipp==3.4.1 pyinstaller -F --additional-hooks-dir ./ --hidden-import pyreadstat._readstat_writer --hidden-import pandas --hidden-import pyreadstat.worker --hidden-import multiprocessing /path/to/damage.py Alternately, you can simplify the PyInstaller command by using the py_install/hook-fcheck.py file: pyinstaller -F --additional-hooks-dir=/path/to/py_install /path/to/damage.py This process will create a damage.spec file along with a build and a dist dir. Inside the dist dir will be your self-contained file, which you can do with as you like. Normally, on MacOS and linux system, the resultant damage file is placed in /usr/local/bin and for Windows computers, the damage.exe file is placed somewhere on you system PATH .","title":"Building damage as standalone application"},{"location":"building_damage_binary/#creating-a-binary-damage","text":"Not everyone has a python installation on their computer, and even if they do, they don\u2019t necessarily know how to use it. As damage is supposed to be simple to use, the easiest way to use it is as a traditional application. This means it needs to be compiled or packaged into, ideally, a single file. Note that you only need to this if there is not a binary version of damage available for your platform. Normally you would just download the software from the releases page. Users most likely to require a custom binary version of damage are: Linux users Mac users who are using machines with M1 processors Users with ARM chips or other uncommon system architecture To perform these steps, you will need [PyInstaller] along with an installed version of Python >= v3.6. Although these examples use absolute paths, that\u2019s not technically required. You can install PyInstaller the usual way with pip . ie. pip install PyInstaller","title":"Creating a binary damage"},{"location":"building_damage_binary/#building-with-pyinstaller","text":"Depending on your Python installation, you may need to build with a virtual environment (which you should probably do anyway). Damage doesn\u2019t have a lot of dependencies; you really only need pyreadstat, which installs pandas and numpy as dependencies. or, as the output of pip freeze : altgraph==0.17 importlib-metadata==4.0.1 macholib==1.14 numpy==1.20.2 pandas==1.2.4 pyinstaller==4.3 pyinstaller-hooks-contrib==2021.1 pyreadstat==1.1.0 python-dateutil==2.8.1 pytz==2021.1 six==1.15.0 typing-extensions==3.10.0.0 zipp==3.4.1 pyinstaller -F --additional-hooks-dir ./ --hidden-import pyreadstat._readstat_writer --hidden-import pandas --hidden-import pyreadstat.worker --hidden-import multiprocessing /path/to/damage.py Alternately, you can simplify the PyInstaller command by using the py_install/hook-fcheck.py file: pyinstaller -F --additional-hooks-dir=/path/to/py_install /path/to/damage.py This process will create a damage.spec file along with a build and a dist dir. Inside the dist dir will be your self-contained file, which you can do with as you like. Normally, on MacOS and linux system, the resultant damage file is placed in /usr/local/bin and for Windows computers, the damage.exe file is placed somewhere on you system PATH .","title":"Building with Pyinstaller"},{"location":"credits/","text":"Credits \u00b6 Contact \u00b6 fcheck and damage were written by Paul Lesack of the University of British Columbia Library Research Commons . Acknowledgements \u00b6 Many thanks to Jeremy Buhler for coming up with the damage name. Reading statistical file metadata is made very simple with pyreadstat . Without pydoc-markdown , mkdocs , documentation would have been a lot harder.","title":"Credits"},{"location":"credits/#credits","text":"","title":"Credits"},{"location":"credits/#contact","text":"fcheck and damage were written by Paul Lesack of the University of British Columbia Library Research Commons .","title":"Contact"},{"location":"credits/#acknowledgements","text":"Many thanks to Jeremy Buhler for coming up with the damage name. Reading statistical file metadata is made very simple with pyreadstat . Without pydoc-markdown , mkdocs , documentation would have been a lot harder.","title":"Acknowledgements"},{"location":"faq/","text":"Frequently asked questions \u00b6 Why would you call the software \u201cdamage\u201d? Command line utility names are not easy to remember. Typing \u2018damage [filename\u2019] for the first time will burn the name into your memory. Can I rename the program? If you don\u2019t like the frisson of danger from the name, you can rename the binary files to whatever you like. manifest_generator is an obvious, if lengthy choice. Why does the software hang during examination of text files? Most of the time, the software hasn\u2019t actually crashed; it\u2019s still doing its processing, possibly more slowly than one would like. There can be two reasons for this: Every character in a text file is examined; if your file is large, the amount of time this requires is not negligble. There have been instances of file corruption where data is replaced by null characters . Using versions previous to v0.1.3 output the row and column location of every such character, which takes a very long time if there are, as has happened, tens of millions of these characters. Versions >= v0.1.3 changed this behaviour and simply output a count. TLDR; upgrade to the latest version.","title":"Frequently asked questions"},{"location":"faq/#frequently-asked-questions","text":"Why would you call the software \u201cdamage\u201d? Command line utility names are not easy to remember. Typing \u2018damage [filename\u2019] for the first time will burn the name into your memory. Can I rename the program? If you don\u2019t like the frisson of danger from the name, you can rename the binary files to whatever you like. manifest_generator is an obvious, if lengthy choice. Why does the software hang during examination of text files? Most of the time, the software hasn\u2019t actually crashed; it\u2019s still doing its processing, possibly more slowly than one would like. There can be two reasons for this: Every character in a text file is examined; if your file is large, the amount of time this requires is not negligble. There have been instances of file corruption where data is replaced by null characters . Using versions previous to v0.1.3 output the row and column location of every such character, which takes a very long time if there are, as has happened, tens of millions of these characters. Versions >= v0.1.3 changed this behaviour and simply output a count. TLDR; upgrade to the latest version.","title":"Frequently asked questions"},{"location":"how_to_use_damage/","text":"How to use the damage utility \u00b6 Currently, this utility works as a console utility, ie. a Windows command prompt or terminal is required for use. If you have installed the fcheck module with pip damage.py [options] If using the binary, and the binary is in your $PATH damage [options] If using Python directly from the source code, invoke the utility with: python3 /path/to/damage.py [options] Note that on Windows this means something like: python3 C:\\path\\to\\damage.py [options] Outputting to a file By default, the program will spit its results to the screen (stdout). To send the output to a file, run the utility and pipe the output to a file. For example: damage -o csv -r ./ > C:\\temp\\output.csv Program options \u00b6 usage: damage.py [-h] [-v] [-o OUT] [-n] [-r] [-t DIGEST] files [files ...] Produces a text, csv or JSON output with checksums for files, testing for Windows CRLF combinations, as well as checking text files for regularity and non/ASCII characters positional arguments: files Files to check. Wildcards acceptable (eg, *) optional arguments: -h, --help show this help message and exit -v, --version Show version number and exit -o OUT, --output OUT Output format. One of txt, csv, json -n, --no-flat Don't check text files for rectangularity -r, --recursive Recursive *directory* processing of file tree. Assumes that the arguments point to a directory (eg, tmp/), and a slash will be appended if one does not exist -t DIGEST, --hash-type DIGEST Checksum hash type. Supported hashes: 'sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'blake2b', 'blake2s', 'md5'. Default: 'md5' Compiling/packaging the software on your platform \u00b6 Making your own damage binary if the supplied ones don\u2019t meet your needs is easy. See the how to create a standalone application page for details.","title":"How to use the damage utility"},{"location":"how_to_use_damage/#how-to-use-the-damage-utility","text":"Currently, this utility works as a console utility, ie. a Windows command prompt or terminal is required for use. If you have installed the fcheck module with pip damage.py [options] If using the binary, and the binary is in your $PATH damage [options] If using Python directly from the source code, invoke the utility with: python3 /path/to/damage.py [options] Note that on Windows this means something like: python3 C:\\path\\to\\damage.py [options] Outputting to a file By default, the program will spit its results to the screen (stdout). To send the output to a file, run the utility and pipe the output to a file. For example: damage -o csv -r ./ > C:\\temp\\output.csv","title":"How to use the damage utility"},{"location":"how_to_use_damage/#program-options","text":"usage: damage.py [-h] [-v] [-o OUT] [-n] [-r] [-t DIGEST] files [files ...] Produces a text, csv or JSON output with checksums for files, testing for Windows CRLF combinations, as well as checking text files for regularity and non/ASCII characters positional arguments: files Files to check. Wildcards acceptable (eg, *) optional arguments: -h, --help show this help message and exit -v, --version Show version number and exit -o OUT, --output OUT Output format. One of txt, csv, json -n, --no-flat Don't check text files for rectangularity -r, --recursive Recursive *directory* processing of file tree. Assumes that the arguments point to a directory (eg, tmp/), and a slash will be appended if one does not exist -t DIGEST, --hash-type DIGEST Checksum hash type. Supported hashes: 'sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'blake2b', 'blake2s', 'md5'. Default: 'md5'","title":"Program options"},{"location":"how_to_use_damage/#compilingpackaging-the-software-on-your-platform","text":"Making your own damage binary if the supplied ones don\u2019t meet your needs is easy. See the how to create a standalone application page for details.","title":"Compiling/packaging the software on your platform"}]}